# 우선순위 큐(Priority Queue)

- **우선순위 큐는 우선순위의 개념을 큐에 도입한 자료구조**
  - 즉, 우선순위를 가진 항목들을 저장하는 큐
  - 일반적인 큐는 `선입선출(FIFO)`의 원칙에 의하여 먼저 들어온 데이터가 먼저 나가는 구조
  - **우선순위 큐는 데이터들이 우선순위를 가지고 있고 우선순위가 높은 데이터가 먼저 나가는 구조**
- 우선순위 큐는 `배열`, `연결리스트` 등의 여러가지 방법으로 구현이 가능한데 **가장 효율적인 구조는 힙(heap)**
  - `최대 우선순위 큐`: **최대 힙** 사용
  - `최소 우선순위 큐`: **최소 힙** 사용

- 우선순위 큐는 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제에서의 작업 스케쥴링, 수치 해석적인 계산 등에 사용





# 힙(Heap)

### 개념

- 힙은 **완전이진트리** 기반의 모습이 비슷한 특정 자료구조
- **힙은 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조**
  - **부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진트리**
  - `최대 힙(max heap)`: 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전이진트리 **[key(자식노드) <= key(부모노드)]**
  - `최소 힙(min heap)`: 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전이진트리 **[key(부모노드) <= key(자식노드)]**
- 힙 트리는 `완전이진트리`이면서 중복된 값을 허용
  - 이진탐색트리는 노드의 키 값이 유일
- 힙 안에서 데이터들은 **반정렬 상태**를 유지
  - **힙은 이러한 반정렬 상태를 이용하여 우선순위 큐를 구현**
  - 힙의 효율은 O(logn)으로서 배열이나 연결리스트를 이용하여 구현한 방법보다 상당히 유리



### 구현

- **힙을 저장하는 표준적인 자료구조는 배열**
  - 힙은 완전이진트리이기 때문에 각각의 노드에 차례대로 번호를 부여
  - 이 번호를 `배열의 인덱스`로 생각하면 배열에 힙의 노드를 저장 가능
- **배열을 이용하여 힙을 저장하면 완전이진트리에서처럼 부모노드와 자식노드를 쉽게 파악 가능**
  - 부모의 인덱스 = (자식의 인덱스) / 2
  - 왼쪽 자식의 인덱스 = (부모의 인덱스 * 2)
  - 오른쪽 자식의 인덱스 = (부모의 인덱스 * 2) + 1



### 연산

**삽입 연산**

```
1. 힙의 끝에 새로운 노드를 삽입
2. 삽입된 노드와 그 부모노드의 키 값을 비교 후 삽입된 노드의 키 값이 부모노드의 키 값보다 크면 두 노드의 위치를 교환
3. 삽입된 노드의 키 값이 자신의 부모노드 키 값보다 작아질 때까지 단계 2를 반복
```

- 삽입연산의 시간복잡도: `O(logn)`
  - 새 요소가 힙을 타고 올라가면서 부모 노드들과 교환을 하게 되는데 최악의 경우 루트  노드까지 올라가야 하므로 트리 높이에 해당하는 비교 연산 및 이동 연산이 필요
  - **완전이진트리 구조**인 힙의 높이는 logn이므로 시간복잡도는 O(logn)



**삭제 연산**

```
1. 루트 삭제 후 빈 자리에 힙의 마지막 노드를 이동
2. 새로운 루트와 자식노드를 비교하며 자식노드의 키 값이 크면 두 노드의 위치를 교환
3. 힙의 성질을 만족할 때까지 단계 2를 반복
```

- 삭제연산의 시간복잡도: `O(logn)`
  - 마지막 노드를 루트로 가져온 후에 자식 노드들과 비교하여 교환하는 부분이 가장 시간이 걸리는 부분
  - 최악의 경우 가장 아래 레벨까지 내려가야 하므로 마찬가지로 트리의 높이만큼 시간이 소요